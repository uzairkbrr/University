# Data Structures and Algorithms Problems

## Arrays & Matrices
1. Given a 6×6 input matrix, compute an output matrix where each element is the average of its neighbors.
2. Find common elements in two char arrays (no duplicates, no array indices).
3. Delete elements by position/value in an array (no array indices).
4. Reverse an array (no array indices).
5. Read integers from a text file into a 5×5 array, compute row-wise sums, and store in a 1D array.
6. Dynamic memory allocation for 1D/2D/3D arrays using pointers.
7. Implement a list ADT using arrays (create, insert, delete, search, display).

## Pointers & Dynamic Memory
1. Print a multiplication table using pointers and recursion.
2. Find common letters in two char arrays using pointers (no array indices).
3. Use pointers to input a table number/limit and print the table (sentinel-terminated).
4. Pointer arithmetic, dereferencing, pointers to pointers.
5. Passing pointers to functions (e.g., swap values).
6. Pointer-based string manipulation.

## Linked Lists
### Singly Linked List
1. Insert 15 random integers (0–100) and compute median/mode.
2. Copy a list in reverse order.
3. Check if a list is a palindrome.

### Doubly Linked List
1. Check if sorted.
2. Split into front/back halves (odd-length: front gets extra node).

### Circular Linked List
1. Menu-driven operations: `InsertAtBegin`, `DeleteAtEnd`, `Print`.

## Stacks & Queues
1. Implement stack using queue (`Enqueue`, `Dequeue`, `IsEmpty`, `IsFull`, `Print`).
2. Duplicate queue nodes based on node count (e.g., `3→4→5` becomes `3,3,3,4,4,4,5,5,5`).
3. Array-based queue to simulate a processor scheduler (FIFO) with process ID, state, and time.

## Trees
### Binary Search Tree (BST)
1. Array-based implementation (insert, delete, search, traversals).
2. Count nodes at a given height.
3. Count leaf nodes.
4. Count all parent nodes.
5. Concatenate two BSTs.
6. Convert a BST to an AVL tree and print before/after.
7. Given a BST, find siblings, ancestors, descendants, and check completeness.

### Heap/Priority Queue
1. Simulate a messenger buffer (prioritize messages by timestamp/priority).

## Recursion
1. Count unique ways to climb `N` steps (1 or 2 steps at a time). Generalize for any step set `X` (e.g., {1, 3, 5}).
2. Print multiplication table using recursion + pointers.

## String & Regex
1. Password validation (length 5–11, 1 digit, 1 uppercase, 1 special char).
2. Email validation (format `prefix@domain.com`, valid domain, prefix rules).

## File Handling
1. Read integers from a file into a 5×5 array and compute row sums.
